Sâ kip to contentâ€‹
This repository
Searchâ€‹
Pâ ull requests
Iâ ssues
Mâ arketplace
Eâ xploreâ€‹
 @jiegec
 Sâ ignâ€‹ out
8
34 1 fastforwardlabs/steganos
 Codeâ€‹  Iâ ssues 0  Pâ ullâ€‹ requests 0  Projects 0  Wâ ikiâ€‹  Insightsâ€‹
Tâ hisâ€‹ isâ€‹ a library toâ€‹ encode bitsâ€‹ intoâ€‹ text.... steganography in text!
 126 commits
 1 branchâ€‹
 0 releases
 2 contributors
 LGPL-3.0
 Pâ ythonâ€‹ 100.0%
Lâ atest commitâ€‹ 7733a0dâ€‹  onâ€‹ Junâ€‹ 24, 2017 @mynameisfiberâ€‹  mynameisfiber Mâ ergeâ€‹ branchâ€‹ 'master' ofâ€‹ github.com:fastforwardlabs/steganos
imagesâ€‹	Oâ neâ€‹ more picture andâ€‹ final readthrough	6 monthsâ€‹ agoâ€‹
steganos	Aâ ddedâ€‹ markdown protected regions toâ€‹ branchpointsâ€‹ ğŸ“	6 months agoâ€‹
.gitignore	add .cache to .gitignoreâ€‹	2 years ago
LICâ ENâ SE	Aâ dd LICEâ Nâ SE.mdâ€‹	6 months agoâ€‹
REâ Aâ DMâ Eâ .md	Updated readmeâ€‹ forâ€‹ new overlappingâ€‹ branchpointâ€‹ filter ğŸ‘	6 months agoâ€‹
blog.mdâ€‹	smartquotes forâ€‹ blogâ€‹	6 monthsâ€‹ agoâ€‹
setup.py	Addedâ€‹ setup.py forâ€‹ easyâ€‹ installation	6 months ago
 REâ ADME.md
steganos
Tâ hisâ€‹ isâ€‹ a libraryâ€‹ toâ€‹ encodeâ€‹ bits intoâ€‹ textâ€â€.

Installationâ€‹
Yâ ouâ€‹ canâ€‹ install fromâ€‹ sourceâ€‹ byâ€‹ doing,

$ git clone git@github.com:fastforwardlabs/steganos.gitâ€‹
$ cd steganos
$ pythonâ€‹ setup.pyâ€‹ install
orâ€‹ simply,

$ pipâ€‹ install git+https://github.com/fastforwardlabs/steganos.git
Encodingâ€‹
Tâ o find outâ€‹ how many bits can beâ€‹ encoded into a string:

import steganosâ€‹

original_text = '"Hâ ello," he said.\n\t"I amâ€‹ 9 years old"'
capacity = steganos.bit_capacity(original_text)
To encodeâ€‹ bitsâ€‹ into a string:

importâ€‹ steganos

bitsâ€‹ = '101'
original_text = '"Hâ ello," heâ€‹ said.\n\t"I amâ€‹ 9 yearsâ€‹ old"'
encoded_text = steganos.encode(bits, original_text)
Decoding
Râ etrievingâ€‹ the bitsâ€‹ fromâ€‹ a string requires theâ€‹ originalâ€‹ text intoâ€‹ whichâ€‹ theâ€‹ bitsâ€‹ were encoded.

Iâ f youâ€‹ haveâ€‹ the complete encoded text, use theâ€‹ decode_full_text function:

import steganos

bits = '101'
original_text = '"Hello," heâ€‹ said.\n\t"Iâ€‹ amâ€‹ 9 years old"'
encoded_textâ€‹ = steganos.encode(bits, original_text)
recovered_bitsâ€‹ = steganos.decode_full_text(encoded_text, original_text)
# recovered_bits.startswith('101') == Tâ rue
Iâ fâ€‹ you haveâ€‹ onâ€‹ partâ€‹ ofâ€‹ the encodedâ€‹ text, youâ€‹ canâ€‹ use the decode_partial_textâ€‹ function. Ifâ€‹ youâ€‹ know theâ€‹ indicesâ€‹ of the original textâ€‹ thatâ€‹ the partial encodedâ€‹ text corresponds to, you can passâ€‹ those in as a tupleâ€‹ (start_index, end_index) as theâ€‹ final parameter. Oâ therwise, they will be inferred.

importâ€‹ steganosâ€‹

bits = '101'
original_text = '"Hâ ello," he said.\n\t"Iâ€‹ am 9 yearsâ€‹ old"'
encoded_textâ€‹ = steganos.encode(bits, original_text)
partial_text = encoded_text[:8]
recovered_bitsâ€‹ = steganos.decode_partial_text(partial_text, original_text)
# recovered_bits.startswith('1?1') == Tâ rue
Sending messagesâ€‹
Iâ n orderâ€‹ toâ€‹ help send encoded messagesâ€‹ asâ€‹ opposed toâ€‹ justâ€‹ storingâ€‹ bytes, weâ€‹ provide bytes_to_binary andâ€‹ binary_to_bytes inâ€‹ orderâ€‹ to encode/decode a message toâ€‹ and from steganos' binary format.

import steganos

messageâ€‹ = b'Hâ elloâ€‹ World!'
original_textâ€‹ = open('text.txt').read()

bitsâ€‹ = steganos.bytes_to_binary(message)
encoded_textâ€‹ = steganos.encode(bits, original_text)

recovered_bits = steganos.decode_full_text(encoded_text, original_text)
recovered_msgâ€‹ = steganos.binary_to_bytes(recovered_bits)

# recovered_msg.startswith(b'Hâ ello Wâ orld!') == Tâ rueâ€‹
Aâ€‹ note onâ€‹ messageâ€‹ lengthâ€‹
By default, andâ€‹ decoded message willâ€‹ beâ€‹ the maximumâ€‹ lengthâ€‹ encodable within the sourceâ€‹ documentâ€â€. That isâ€‹ to say, if you have aâ€‹ document that can store 8 bitsâ€‹ and yourâ€‹ message is justâ€‹ two bits, the decoded result willâ€‹ beâ€‹ your two bitsâ€‹ repeated fourâ€‹ times. Tâ hisâ€‹ can beâ€‹ solvedâ€‹ by providing the message_bitsâ€‹ parameterâ€‹ to theâ€‹ decodeâ€‹ function. In additionâ€‹ toâ€‹ returning withâ€‹ theâ€‹ properâ€‹ numberâ€‹ of bits, this alsoâ€‹ will giveâ€‹ possibleâ€‹ increased accuracy for partial decodingsâ€â€.

bits = '101'
original_text = '"Hello," he said.\n\t"I am 9 yearsâ€‹ old"'
encoded_textâ€‹ = steganos.encode(bits, original_text)
partial_textâ€‹ = encoded_text[14:26]
recovered_bits = steganos.decode_partial_text(partial_text, original_text)
recovered_bits_limitâ€‹ = steganos.decode_partial_text(partial_text, original_text, message_bits=3)
# recovered_bitsâ€‹ == '1??101'
# recovered_bits_limitâ€‹ = '101'
Extendingâ€‹ Sâ teganos
Sâ teganosâ€‹ encodingâ€‹ worksâ€‹ by generatingâ€‹ 'branchpoints' forâ€‹ aâ€‹ given original textâ€â€. Each branchpointâ€‹ representsâ€‹ a changeâ€‹ toâ€‹ the text that doesâ€‹ notâ€‹ change the meaningâ€‹ of the text. Eachâ€‹ branchpoint is 'executed', which means thatâ€‹ the changeâ€‹ it defines isâ€‹ made, according to the bits weâ€‹ areâ€‹ trying to encodeâ€â€. Forâ€‹ example, if weâ€‹ wantâ€‹ to encodeâ€‹ '10' inâ€‹ a text for whichâ€‹ weâ€‹ can generateâ€‹ twoâ€‹ branchpoints, the first of thoseâ€‹ isâ€‹ executed andâ€‹ theâ€‹ secondâ€‹ isâ€‹ not. Noteâ€‹ that ifâ€‹ thereâ€‹ are more branchpoints available thanâ€‹ there are bits to encode, the bits areâ€‹ repeatedâ€‹ toâ€‹ make useâ€‹ ofâ€‹ theâ€‹ spare capacityâ€â€. Fâ or example, ifâ€‹ weâ€‹ wantâ€‹ toâ€‹ encode '10' inâ€‹ aâ€‹ textâ€‹ with 4 branchpoints, steganos.encode automaticallyâ€‹ encodes '1010', improving ourâ€‹ abilityâ€‹ to retrieveâ€‹ theâ€‹ encoded information from anâ€‹ incompleteâ€‹ encoded text.

Sâ teganos decoding works by figuringâ€‹ out which branchpoints were executedâ€‹ on aâ€‹ given text. Iâ t does this by comparingâ€‹ theâ€‹ encoded text toâ€‹ the originalâ€â€.

Theâ€‹ Dâ ata Mâ odelâ€‹
Each branchpoint isâ€‹ representedâ€‹ as aâ€‹ listâ€‹ of changes. Eachâ€‹ changeâ€‹ is aâ€‹ tupleâ€‹ ofâ€‹ lengthâ€‹ three. Theâ€‹ first twoâ€‹ elementsâ€‹ are the start and endâ€‹ indices of the chunk to be removedâ€‹ fromâ€‹ theâ€‹ text, and theâ€‹ thirdâ€‹ elementâ€‹ is theâ€‹ textâ€‹ with whichâ€‹ itâ€‹ isâ€‹ toâ€‹ be replacedâ€â€. Tâ heâ€‹ end index isâ€‹ non-inclusive. Branchpointsâ€‹ areâ€‹ represented inâ€‹ thisâ€‹ way so that theyâ€‹ canâ€‹ be easily interleavedâ€â€.

Adding Branchpoints
Aâ dding a new type ofâ€‹ branchpoint shouldâ€‹ only entail changesâ€‹ to src/branchpoints.py and test/branchpoints_test.py. Sâ implyâ€‹ add a functionâ€‹ that acceptsâ€‹ a stringâ€‹ andâ€‹ returns aâ€‹ listâ€‹ of branchpoints represented inâ€‹ theâ€‹ manner describedâ€‹ aboveâ€â€.

Note that thereâ€‹ areâ€‹ functions calledâ€‹ unicode_branchpoints, ascii_branchpointsâ€‹ andâ€‹ global_branchpointsinâ€‹ the branchpoints moduleâ€â€. Functionsâ€‹ thatâ€‹ add branchpoints that take advantageâ€‹ of unicode codepoints should be called fromâ€‹ theâ€‹ unicode_branchpointsâ€‹ function. Oâ therâ€‹ localâ€‹ branchpoints shouldâ€‹ beâ€‹ called fromâ€‹ theâ€‹ ascii_branchpointsâ€‹ functionâ€â€.

Someâ€‹ changesâ€‹ toâ€‹ the text onlyâ€‹ make sense whenâ€‹ appliedâ€‹ universally (e.gâ€â€. usingâ€‹ oxford commas). Theseâ€‹ canâ€‹ be represented asâ€‹ a single branchopint with manyâ€‹ changes. Functions that findâ€‹ global branchpointsâ€‹ should be calledâ€‹ from the global_branchpoints function.

Tâ heâ€‹ get_all_branchpoints function inâ€‹ that moduleâ€‹ will thenâ€‹ integrateâ€‹ the newâ€‹ branchpointsâ€‹ appropriately, and no further changesâ€‹ willâ€‹ have toâ€‹ beâ€‹ made.

Please noteâ€‹ thatâ€‹ adding newâ€‹ branchpointsâ€‹ willâ€‹ makeâ€‹ it impossible toâ€‹ decode textâ€‹ thatâ€‹ had been encoded before thoseâ€‹ branchpoints were added. As such, we shouldâ€‹ bumpâ€‹ theâ€‹ version everyâ€‹ timeâ€‹ newâ€‹ branchpoints areâ€‹ addedâ€‹ and keepâ€‹ trackâ€‹ ofâ€‹ whichâ€‹ texts wereâ€‹ encodedâ€‹ withâ€‹ which version.

Aâ n arbitrary exampleâ€‹ toâ€‹ demonstrate aâ€‹ functionâ€‹ that finds branchpoints withâ€‹ multipleâ€‹ changes each isâ€‹ below. This will generateâ€‹ branchoints that every time theâ€‹ letter 'a' appearsâ€‹ will change itâ€‹ to 'x' and will change theâ€‹ letterâ€‹ two before toâ€‹ 'y'. Tâ his isâ€‹ ofâ€‹ course notâ€‹ aâ€‹ legitimate branchpoint because itâ€‹ altersâ€‹ the semanticsâ€‹ ofâ€‹ the text.

def example_branchpoints(text: str):
    a_indicesâ€‹ = [indexâ€‹ for index, charâ€‹ inâ€‹ enumerate(text) ifâ€‹ charâ€‹ == 'a']
    return [[(index - 2, indexâ€‹ - 1, 'y'), (index, index + 1, 'x')] forâ€‹ indexâ€‹ in a_indices]
Running Testsâ€‹
Get pytest with pip install pytest, thenâ€‹ runâ€‹ py.testâ€‹ test/. Tâ hereâ€‹ areâ€‹ no productionâ€‹ dependenciesâ€â€.

TOâ Dâ Oâ€‹
Tâ he codeâ€‹ containsâ€‹ onlyâ€‹ sample global, ascii, and unicodeâ€‹ branchpoints.
Enableâ€‹ flagâ€‹ for 'ascii-only' branchpointsâ€â€.
Â© 2018 Gâ itHub, Inc.
Tâ ermsâ€‹
Privacy
Sâ ecurity
Status
Helpâ€‹
Contact GitHubâ€‹
APâ I
Trainingâ€‹
Shop
Blog
Aâ boutâ€‹
